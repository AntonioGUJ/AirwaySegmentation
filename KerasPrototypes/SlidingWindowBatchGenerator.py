#
# created by
# Antonio Garcia-Uceda Juarez
# PhD student
# Medical Informatics
#
# created on 09/02/2018
# Last update: 09/02/2018
########################################################################################

from DataLoaders.LoadDataManager import OperationsArraysUseInKeras
from Preprocessing.SlidingWindowImages import *
from keras.preprocessing import image
import numpy as np
np.random.seed(2017)


class SlidingWindowBatchGenerator(image.Iterator):

    def __init__(self, list_Xdata, list_Ydata, size_image, prop_overlap, num_classes_out=1, size_outnnet=None, batch_size=1, shuffle=True, seed=None):

        self.list_Xdata = list_Xdata
        self.list_Ydata = list_Ydata
        self.type_Xdata = list_Xdata[0].dtype
        self.type_Ydata = list_Ydata[0].dtype

        self.size_image      = size_image
        self.num_classes_out = num_classes_out
        if size_outnnet and (size_outnnet != size_image):
            self.size_outnnet = size_outnnet
        else:
            self.size_outnnet = size_image

        self.opersArrays = OperationsArraysUseInKeras(size_image, num_classes_out=num_classes_out, size_outnnet=size_outnnet)

        self.num_channels_in = self.opersArrays.get_num_channels_array(self.list_Xdata[0].shape)

        self.list_slidingWindow_images_generator = []
        self.list_indexes_compute_images_batches = []

        for ifile, (Xdata, Ydata) in enumerate(zip(list_Xdata, list_Ydata)):

            self.list_slidingWindow_images_generator.append(SlidingWindowImages3D(Xdata.shape, self.size_image, prop_overlap))

            num_images_total = self.list_slidingWindow_images_generator[ifile].get_num_images_total()

            print('File %s: Images generated by Sliding Window: size: %s; num batches: %s...' %(ifile, Xdata.shape, num_images_total))

            for index in range(num_images_total):
                # Store indexes to compute images batches: (idx_fullimage, idx_image_batch
                self.list_indexes_compute_images_batches.append((ifile, index))
            #endfor
        #endfor

        num_images_total_all = len(self.list_indexes_compute_images_batches)

        if (shuffle):
            # shuffle indexes to compute images batches
            randomIndexes = np.random.choice(num_images_total_all, size=num_images_total_all, replace=False)

            list_indexes_compute_images_batches_old = self.list_indexes_compute_images_batches
            self.list_indexes_compute_images_batches = []
            for index in randomIndexes:
                self.list_indexes_compute_images_batches.append(list_indexes_compute_images_batches_old[index])
            #endfor

        super(SlidingWindowBatchGenerator, self).__init__(num_images_total_all, batch_size, shuffle, seed)


    def _get_batches_of_transformed_samples(self, list_indexes_array):

        # overwrite function to retrieve images batches
        num_images_batch = len(list_indexes_array)

        xData_shape = self.opersArrays.get_shape_out_array(num_images_batch, num_channels=self.num_channels_in)
        yData_shape = self.opersArrays.get_shape_out_array(num_images_batch, num_channels=self.num_classes_out)
        Xdata_batch = np.ndarray(xData_shape, dtype=self.type_Xdata)
        Ydata_batch = np.ndarray(yData_shape, dtype=self.type_Ydata)

        for i, index in enumerate(list_indexes_array):

            (Xdata_batch_elem, Ydata_batch_elem) = self.get_XYdata_index_batch(index)

            Xdata_batch_elem = self.opersArrays.get_array_reshaped_Keras(self.opersArrays.get_array_reshaped(Xdata_batch_elem))

            if self.num_classes_out > 1:
                Ydata_batch_elem = self.opersArrays.get_array_reshaped_Keras(self.opersArrays.get_array_categorical_masks(self.opersArrays.get_array_cropImages_outNnet(Ydata_batch_elem)))
            else:
                Ydata_batch_elem = self.opersArrays.get_array_reshaped_Keras(self.opersArrays.get_array_reshaped(self.opersArrays.get_array_cropImages_outNnet(Ydata_batch_elem)))

            # apply transformations
            (Xdata_batch[i], Ydata_batch[i]) = self.get_transformed_XYdata_batch(Xdata_batch_elem, Ydata_batch_elem)
        #endfor

        return (Xdata_batch, Ydata_batch)


    def get_XYdata_index_batch(self, index):

        (idx_fullimage, index_image_batch) = self.list_indexes_compute_images_batches[index]

        return (self.list_slidingWindow_images_generator[idx_fullimage].get_image_array(self.list_Xdata[idx_fullimage], index_image_batch),
                self.list_slidingWindow_images_generator[idx_fullimage].get_image_array(self.list_Ydata[idx_fullimage], index_image_batch))


    def get_transformed_XYdata_batch(self, Xdata_batch_elem, Ydata_batch_elem):
        # do nothing
        return (Xdata_batch_elem, Ydata_batch_elem)


class SlidingWindowPlusDataAugmentationBatchGenerator(SlidingWindowBatchGenerator):

    def __init__(self, list_Xdata, list_Ydata, size_image, prop_overlap, num_classes_out=1, size_outnnet=None, batch_size=1, shuffle=True, seed=None,
                 is_normalize_data=False,
                 type_normalize_data='featurewise',
                 rotation_range=0.0,
                 width_shift_range=0.0,
                 height_shift_range=0.0,
                 shear_range=0.0,
                 zoom_range=0.0,
                 channel_shift_range=0.0,
                 horizontal_flip=False,
                 vertical_flip=False,
                 rescale=None):

        if is_normalize_data:
            if type_normalize_data == 'featurewise':
                featurewise_center = True
                featurewise_std_normalization = True
                samplewise_center = False
                samplewise_std_normalization = False
            else: #type_normalize_data == 'samplewise'
                featurewise_center = False
                featurewise_std_normalization = False
                samplewise_center = True
                samplewise_std_normalization = True
        else:
            featurewise_center = False
            featurewise_std_normalization = False
            samplewise_center = False
            samplewise_std_normalization = False

        self.images_data_generator = image.ImageDataGenerator(featurewise_center=featurewise_center,
                                                              samplewise_center=samplewise_center,
                                                              featurewise_std_normalization=featurewise_std_normalization,
                                                              samplewise_std_normalization=samplewise_std_normalization,
                                                              rotation_range=rotation_range,
                                                              width_shift_range=width_shift_range,
                                                              height_shift_range=height_shift_range,
                                                              shear_range=shear_range,
                                                              zoom_range=zoom_range,
                                                              channel_shift_range=channel_shift_range,
                                                              horizontal_flip=horizontal_flip,
                                                              vertical_flip=vertical_flip,
                                                              rescale=rescale)

        print("Apply Data Augmentation by Random Transformation of Images...")
        print("Rotation Range: %s" % (rotation_range))
        print("Horizontal Shift: %s" %(width_shift_range))
        print("Vertical Shift: %s" % (height_shift_range))
        print("Horizontal Flip: %s" % (horizontal_flip))
        print("Vertical Flip: %s" % (vertical_flip))

        super(SlidingWindowPlusDataAugmentationBatchGenerator, self).__init__(list_Xdata, list_Ydata, size_image, prop_overlap, num_classes_out, size_outnnet, batch_size, shuffle, seed)


    def get_transformed_XYdata_batch(self, Xdata_batch_elem, Ydata_batch_elem):
        # IMPORTANT: "image.ImageDataGenerator" is only designed for 2D images.
        # Used for axial transformation of 3D images if applied slicewise, providing the same seed for generation of random 2D transformations
        # IMPORTANT: must apply transformations to ground-truth Y, at the same time as X, to retrieve same random transformation

        fixed_seed = np.random.randint(0,1e+06)

        for i, (slice_Xdata, slice_Ydata) in enumerate(zip(Xdata_batch_elem, Ydata_batch_elem)):

            Xdata_batch_elem[i] = self.images_data_generator.standardize(self.images_data_generator.random_transform(slice_Xdata, seed=fixed_seed))
            Ydata_batch_elem[i] = self.images_data_generator.standardize(self.images_data_generator.random_transform(slice_Ydata, seed=fixed_seed))
        #endfor

        return (Xdata_batch_elem, Ydata_batch_elem)